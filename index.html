<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical 3D Gesture Christmas Tree</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <!-- Tailwind CSS for layout -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #001f3f 0%, #000428 100%);
            color: white;
            font-family: 'Great Vibes', cursive;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 2rem;
            z-index: 10;
        }

        .neon-text {
            font-size: 5.5rem;
            color: #ffd700;
            text-shadow: 
                0 0 10px #ffd700,
                0 0 20px #ffd700,
                0 0 40px #ffae00,
                0 0 80px #ffae00;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .neon-text.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 135px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            transform: scaleX(-1);
            z-index: 20;
            background: rgba(0,0,0,0.5);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
        }

        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .instructions {
            font-family: sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 1rem;
            color: #fff;
            pointer-events: auto;
            border: 1px solid rgba(255, 215, 0, 0.3);
            text-align: center;
        }

        #status-indicator {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: sans-serif;
            padding: 5px 15px;
            border-radius: 15px;
            background: rgba(255, 215, 0, 0.1);
            color: #ffd700;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .loading-screen {
            position: fixed;
            inset: 0;
            background: #000428;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s ease;
        }

        #start-button {
            margin-top: 20px;
            padding: 12px 40px;
            font-size: 1.5rem;
            background: #ffd700;
            color: #000;
            border-radius: 50px;
            cursor: pointer;
            border: none;
            font-family: 'Great Vibes', cursive;
            box-shadow: 0 0 20px #ffd700;
            transition: transform 0.2s;
            display: none; /* 初期隱藏 */
        }

        #start-button:hover { transform: scale(1.1); }

        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid #FFF;
            border-bottom-color: #ffd700;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }

        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <div id="loading" class="loading-screen">
        <span id="spinner" class="loader"></span>
        <div id="loading-text" style="font-family: sans-serif; margin-top: 20px;">正在加載聖誕魔法...</div>
        <button id="start-button">開啟聖誕魔法</button>
    </div>

    <div id="ui-overlay">
        <h1 id="title" class="neon-text">Merry Christmas</h1>
        <div class="instructions">
            <p>✋ <b>張開手掌</b>：粒子消散</p>
            <p>✊ <b>握緊拳頭</b>：聚合成聖誕樹</p>
            <p class="text-xs mt-2 text-yellow-200/60">( 若無攝像頭，請<b>點擊並長按螢幕</b>模擬 )</p>
        </div>
    </div>

    <div id="status-indicator">等待手勢識別...</div>

    <div id="video-container">
        <video id="input-video"></video>
    </div>

    <script>
        /**
         * GLOBAL CONFIG & STATE
         */
        let scene, camera, renderer, particles;
        let particleCount = 8000;
        let isFist = false;
        let lerpSpeed = 0.06;
        let audioCtx, bgmInterval;
        
        const COLORS = [0xFFD700, 0x50C878, 0xFFF8E1, 0xFFD700, 0x00FF7F]; 

        /**
         * AUDIO SYSTEM - 強化的音訊啟動邏輯
         */
        async function startMagic() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
            
            // 隱藏加載層
            const loadingScreen = document.getElementById('loading');
            loadingScreen.style.opacity = '0';
            setTimeout(() => loadingScreen.remove(), 1000);

            playBGM();
        }

        function playBGM() {
            if (bgmInterval) return; // 防止重複播放

            const notes = [64, 67, 71, 74, 76, 71]; // E4, G4, B4, D5, E5, B4
            const playNote = (freq, t) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, t);
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.06, t + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 2);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(t);
                osc.stop(t + 2);
            };

            const sequence = () => {
                notes.forEach((n, i) => {
                    const freq = 440 * Math.pow(2, (n - 69) / 12);
                    playNote(freq, audioCtx.currentTime + i * 0.6);
                });
            };

            sequence();
            bgmInterval = setInterval(sequence, 4000);
        }

        function playSound(type) {
            if(!audioCtx || audioCtx.state !== 'running') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            if(type === 'ting') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1500, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.4);
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            } else {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.6);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
            }
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.6);
        }

        /**
         * THREE.JS CORE
         */
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 18);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
                const color = new THREE.Color(COLORS[i % COLORS.length]);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.12, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            particles.userData.treeTargets = generateTreeShape();
            particles.userData.scatterTargets = generateScatterShape();

            // Background Snow
            const snowGeo = new THREE.BufferGeometry();
            const snowPos = new Float32Array(800 * 3);
            for(let i=0; i<800; i++) {
                snowPos[i*3] = (Math.random()-0.5)*60;
                snowPos[i*3+1] = Math.random()*40;
                snowPos[i*3+2] = (Math.random()-0.5)*60;
            }
            snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
            const snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({ size: 0.05, color: 0xffffff, transparent: true, opacity: 0.4 }));
            scene.add(snow);
            particles.userData.snow = snow;

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Fallback interactions
            window.addEventListener('mousedown', () => { if(audioCtx) audioCtx.resume(); toggleState(true); });
            window.addEventListener('mouseup', () => toggleState(false));
        }

        function generateTreeShape() {
            const targets = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const height = 12;
                const py = Math.random() * height - 4;
                const r = ((height - (py + 4)) / height) * 5;
                const angle = Math.random() * Math.PI * 2;
                const currentR = r * (0.85 + Math.random() * 0.15);
                targets[i * 3] = Math.cos(angle) * currentR;
                targets[i * 3 + 1] = py;
                targets[i * 3 + 2] = Math.sin(angle) * currentR;
                if (i < 300) {
                    const sAngle = Math.random() * Math.PI * 2;
                    const sR = Math.random() * 0.8;
                    targets[i * 3] = Math.cos(sAngle) * sR;
                    targets[i * 3 + 1] = 8.5 + (Math.random() * 0.5);
                    targets[i * 3 + 2] = Math.sin(sAngle) * sR;
                }
            }
            return targets;
        }

        function generateScatterShape() {
            const targets = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const radius = 15 + Math.random() * 20;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                targets[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                targets[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                targets[i * 3 + 2] = radius * Math.cos(phi);
            }
            return targets;
        }

        function toggleState(fist) {
            if (isFist !== fist) {
                isFist = fist;
                const title = document.getElementById('title');
                if (isFist) {
                    playSound('ting');
                    title.classList.add('visible');
                } else {
                    playSound('whoosh');
                    title.classList.remove('visible');
                }
            }
        }

        /**
         * MEDIAPIPE HANDS
         */
        function initHands() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6
            });

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    let closedFingers = 0;
                    [ [8,6], [12,10], [16,14], [20,18] ].forEach(([tip, mid]) => {
                        if (lm[tip].y > lm[mid].y) closedFingers++;
                    });
                    toggleState(closedFingers >= 3);
                    document.getElementById('status-indicator').innerText = isFist ? "✨ 魔法凝聚中 ✨" : "✨ 觸碰星空 ✨";
                } else {
                    document.getElementById('status-indicator').innerText = "等待您的手勢...";
                }
            });

            const cameraPipe = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640, height: 480
            });
            
            cameraPipe.start().then(() => {
                // 加載完成，顯示按鈕
                document.getElementById('spinner').style.display = 'none';
                document.getElementById('loading-text').innerText = "魔法準備就緒！";
                const startBtn = document.getElementById('start-button');
                startBtn.style.display = 'block';
                startBtn.onclick = startMagic;
            }).catch(() => {
                document.getElementById('spinner').style.display = 'none';
                document.getElementById('loading-text').innerText = "摄像头无法启动，请使用鼠标预览";
                const startBtn = document.getElementById('start-button');
                startBtn.style.display = 'block';
                startBtn.onclick = startMagic;
            });
        }

        /**
         * ANIMATION LOOP
         */
        function animate() {
            requestAnimationFrame(animate);

            const posAttr = particles.geometry.attributes.position;
            const positions = posAttr.array;
            const targetSet = isFist ? particles.userData.treeTargets : particles.userData.scatterTargets;

            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;
                positions[ix] += (targetSet[ix] - positions[ix]) * lerpSpeed;
                positions[iy] += (targetSet[iy] - positions[iy]) * lerpSpeed;
                positions[iz] += (targetSet[iz] - positions[iz]) * lerpSpeed;
                if (!isFist) {
                    const time = Date.now() * 0.001;
                    positions[ix] += Math.sin(time + i) * 0.02;
                    positions[iy] += Math.cos(time + i * 0.5) * 0.02;
                }
            }
            posAttr.needsUpdate = true;
            particles.rotation.y += isFist ? 0.008 : 0.002;

            const snowPos = particles.userData.snow.geometry.attributes.position.array;
            for(let i=0; i<800; i++) {
                snowPos[i*3+1] -= 0.05;
                if(snowPos[i*3+1] < -10) snowPos[i*3+1] = 30;
            }
            particles.userData.snow.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        window.onload = () => {
            initThree();
            initHands();
            animate();
        };
    </script>
</body>
</html>