<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magical 3D Gesture Christmas Tree</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <!-- Tailwind CSS for layout -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #001f3f 0%, #000428 100%);
            color: white;
            font-family: 'Great Vibes', cursive;
            touch-action: none; /* 防止手機縮放干擾 */
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 2rem;
            z-index: 10;
        }

        .neon-text {
            font-size: 4rem; /* 手機上縮小一點字體 */
            color: #ffd700;
            text-shadow: 
                0 0 10px #ffd700,
                0 0 20px #ffd700,
                0 0 40px #ffae00;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
        }

        @media (min-width: 768px) {
            .neon-text { font-size: 5.5rem; }
        }

        .neon-text.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 90px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            transform: scaleX(-1);
            z-index: 20;
            background: rgba(0,0,0,0.5);
        }

        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .instructions {
            font-family: sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            color: #fff;
            pointer-events: auto;
            border: 1px solid rgba(255, 215, 0, 0.3);
            text-align: center;
            max-width: 90%;
        }

        #status-indicator {
            position: absolute;
            bottom: 120px; /* 避開影片視窗 */
            left: 50%;
            transform: translateX(-50%);
            font-family: sans-serif;
            padding: 5px 15px;
            border-radius: 15px;
            background: rgba(255, 215, 0, 0.1);
            color: #ffd700;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .loading-screen {
            position: fixed;
            inset: 0;
            background: #000428;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s ease;
        }

        #start-button {
            margin-top: 20px;
            padding: 12px 40px;
            font-size: 1.5rem;
            background: #ffd700;
            color: #000;
            border-radius: 50px;
            cursor: pointer;
            border: none;
            font-family: 'Great Vibes', cursive;
            box-shadow: 0 0 20px #ffd700;
            display: none;
        }

        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid #FFF;
            border-bottom-color: #ffd700;
            border-radius: 50%;
            display: inline-block;
            animation: rotation 1s linear infinite;
        }

        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <div id="loading" class="loading-screen">
        <span id="spinner" class="loader"></span>
        <div id="loading-text" style="font-family: sans-serif; margin-top: 20px; color: #ffd700;">載入魔法模型中...</div>
        <button id="start-button">開啟聖誕魔法</button>
    </div>

    <div id="ui-overlay">
        <h1 id="title" class="neon-text">Merry Christmas</h1>
        <div class="instructions">
            <p>✋ <b>張開手掌</b>：粒子消散</p>
            <p>✊ <b>握緊拳頭</b>：聚合成聖誕樹</p>
            <p class="text-xs mt-1 text-yellow-200/60">( 若無反應，請<b>長按螢幕</b> )</p>
        </div>
    </div>

    <div id="status-indicator">等待權限...</div>

    <div id="video-container">
        <!-- 關鍵：加入 playsinline, autoplay, muted 以適應手機端 -->
        <video id="input-video" playsinline autoplay muted></video>
    </div>

    <script>
        let scene, camera, renderer, particles;
        let particleCount = 6000; // 手機端稍微減少粒子數量以保證效能
        let isFist = false;
        let lerpSpeed = 0.07;
        let audioCtx, bgmInterval;
        const COLORS = [0xFFD700, 0x50C878, 0xFFF8E1, 0xFFD700, 0x00FF7F];

        // --- 音訊系統 ---
        async function startMagic() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
            
            const loadingScreen = document.getElementById('loading');
            loadingScreen.style.opacity = '0';
            setTimeout(() => loadingScreen.remove(), 1000);

            playBGM();
        }

        function playBGM() {
            if (bgmInterval) return;
            const notes = [64, 67, 71, 74, 76, 71]; 
            const sequence = () => {
                notes.forEach((n, i) => {
                    const t = audioCtx.currentTime + i * 0.6;
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440 * Math.pow(2, (n - 69) / 12), t);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.05, t + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 2);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(t);
                    osc.stop(t + 2);
                });
            };
            sequence();
            bgmInterval = setInterval(sequence, 4000);
        }

        function playSound(type) {
            if(!audioCtx || audioCtx.state !== 'running') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            if(type === 'ting') {
                osc.frequency.setValueAtTime(1500, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.4);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            } else {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
            }
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.6);
        }

        // --- 3D 視覺引擎 ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 18);

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }); // 手機關閉 antialias 換效能
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.body.appendChild(renderer.domElement);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 40;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 40;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
                const color = new THREE.Color(COLORS[i % COLORS.length]);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.15, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            particles.userData.treeTargets = generateTreeShape();
            particles.userData.scatterTargets = generateScatterShape();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // 手機端模擬：長按
            const triggerFist = (e) => { 
                if(e.cancelable) e.preventDefault(); 
                if(audioCtx) audioCtx.resume(); 
                toggleState(true); 
            };
            const releaseFist = () => toggleState(false);

            window.addEventListener('touchstart', triggerFist, { passive: false });
            window.addEventListener('touchend', releaseFist);
            window.addEventListener('mousedown', triggerFist);
            window.addEventListener('mouseup', releaseFist);
        }

        function generateTreeShape() {
            const targets = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const height = 12;
                const py = Math.random() * height - 4;
                const r = ((height - (py + 4)) / height) * 5;
                const angle = Math.random() * Math.PI * 2;
                const currentR = r * (0.8 + Math.random() * 0.2);
                targets[i * 3] = Math.cos(angle) * currentR;
                targets[i * 3 + 1] = py;
                targets[i * 3 + 2] = Math.sin(angle) * currentR;
                if (i < 200) { // 星星
                    targets[i * 3 + 1] = 8.5 + (Math.random() * 0.5);
                }
            }
            return targets;
        }

        function generateScatterShape() {
            const targets = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const radius = 15 + Math.random() * 15;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                targets[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                targets[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                targets[i * 3 + 2] = radius * Math.cos(phi);
            }
            return targets;
        }

        function toggleState(fist) {
            if (isFist !== fist) {
                isFist = fist;
                const title = document.getElementById('title');
                if (isFist) {
                    playSound('ting');
                    title.classList.add('visible');
                } else {
                    playSound('whoosh');
                    title.classList.remove('visible');
                }
            }
        }

        // --- AI 手勢識別 ---
        function initHands() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    let closedFingers = 0;
                    [ [8,6], [12,10], [16,14], [20,18] ].forEach(([tip, mid]) => {
                        if (lm[tip].y > lm[mid].y) closedFingers++;
                    });
                    toggleState(closedFingers >= 3);
                    document.getElementById('status-indicator').innerText = isFist ? "✨ 魔法凝聚 ✨" : "✨ 聖誕星塵 ✨";
                } else {
                    document.getElementById('status-indicator').innerText = "請將手放在鏡頭前";
                }
            });

            const cameraPipe = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640, height: 480
            });
            
            cameraPipe.start().then(() => {
                document.getElementById('spinner').style.display = 'none';
                document.getElementById('loading-text').innerText = "準備好了！";
                const startBtn = document.getElementById('start-button');
                startBtn.style.display = 'block';
                startBtn.onclick = startMagic;
            }).catch((err) => {
                console.error(err);
                document.getElementById('spinner').style.display = 'none';
                document.getElementById('loading-text').innerText = "相機啟動失敗，改用點擊模式";
                const startBtn = document.getElementById('start-button');
                startBtn.style.display = 'block';
                startBtn.onclick = startMagic;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const posAttr = particles.geometry.attributes.position;
            const positions = posAttr.array;
            const targetSet = isFist ? particles.userData.treeTargets : particles.userData.scatterTargets;

            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;
                positions[ix] += (targetSet[ix] - positions[ix]) * lerpSpeed;
                positions[iy] += (targetSet[iy] - positions[iy]) * lerpSpeed;
                positions[iz] += (targetSet[iz] - positions[iz]) * lerpSpeed;
            }
            posAttr.needsUpdate = true;
            particles.rotation.y += isFist ? 0.008 : 0.003;
            renderer.render(scene, camera);
        }

        window.onload = () => {
            initThree();
            initHands();
            animate();
        };
    </script>
</body>
</html>