<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magical 3D Gesture Christmas Tree</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands (Pinned Version for Stability) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #001f3f 0%, #000428 100%);
            color: white;
            font-family: 'Great Vibes', cursive;
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 2rem;
            z-index: 10;
        }

        .neon-text {
            font-size: 3.5rem;
            color: #ffd700;
            text-shadow: 0 0 15px #ffd700, 0 0 30px #ffae00;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 1.2s ease;
            text-align: center;
            margin-top: 20px;
        }

        .neon-text.visible { opacity: 1; transform: translateY(0); }

        #video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 75px;
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            transform: scaleX(-1);
            z-index: 20;
            background: #000;
            display: none; 
            opacity: 0.8;
        }

        #input-video { width: 100%; height: 100%; object-fit: cover; }

        .instructions {
            font-family: sans-serif;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            color: #eee;
            pointer-events: auto;
            text-align: center;
            border: 1px solid rgba(255, 215, 0, 0.2);
            backdrop-filter: blur(4px);
            margin-bottom: 40px; 
        }

        .loading-screen {
            position: fixed;
            inset: 0;
            background: #000428;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        #start-button {
            position: relative;
            padding: 15px 50px;
            font-size: 1.5rem;
            background: linear-gradient(45deg, #ffd700, #ffae00);
            color: #000;
            border-radius: 50px;
            border: none;
            font-family: 'Great Vibes', cursive;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
            font-weight: bold;
            margin-top: 30px;
            pointer-events: auto !important;
            touch-action: manipulation !important;
            cursor: pointer;
            z-index: 10000;
        }
        
        #start-button:active {
            transform: scale(0.95);
            background: #ffae00;
        }

        #status-log {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-family: sans-serif;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            width: 90%;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading" class="loading-screen">
        <div style="font-family: sans-serif; font-size: 1.2rem; color: #ffd700; margin-bottom: 10px;">Magical Tree</div>
        <div style="font-family: sans-serif; font-size: 0.9rem; color: #aaa;">å»ºè­°ä½©æˆ´è€³æ©Ÿ</div>
        <button id="start-button">é–‹å•Ÿè–èª•é­”æ³•</button>
    </div>

    <div id="ui-overlay">
        <h1 id="title" class="neon-text">Merry Christmas</h1>
        <div class="instructions">
            <p>ğŸ‘† <b>é•·æŒ‰è¢å¹•</b> å‡èšè–èª•æ¨¹</p>
            <p id="cam-hint" class="text-xs mt-1 opacity-60" style="display:none;">( æˆ–ä½¿ç”¨æ‰‹å‹¢ï¼šå¼µé–‹/æ¡æ‹³ )</p>
        </div>
    </div>

    <div id="status-log">æº–å‚™å°±ç·’</div>

    <div id="video-container">
        <video id="input-video" playsinline autoplay muted></video>
    </div>

    <script>
        // --- éŒ¯èª¤è™•ç†ï¼šé˜²æ­¢ Fetch éŒ¯èª¤å°è‡´å´©æ½° ---
        window.addEventListener('unhandledrejection', function(event) {
            console.warn("æ•æ‰åˆ°æœªè™•ç†çš„ Promise éŒ¯èª¤:", event.reason);
            // å¿½ç•¥ Failed to fetch éŒ¯èª¤ï¼Œè®“ç¨‹å¼ç¹¼çºŒé‹è¡Œ
            if (event.reason && event.reason.message && event.reason.message.includes('fetch')) {
                const log = document.getElementById('status-log');
                if (log) log.innerText = "ç¶²è·¯è³‡æºå—é™ï¼Œè«‹ä½¿ç”¨è§¸æ§æ¨¡å¼";
                event.preventDefault(); 
            }
        });

        // --- å…¨å±€è®Šæ•¸ ---
        let scene, camera, renderer, particles;
        const particleCount = window.innerWidth < 768 ? 3000 : 7000; 
        let isFist = false;
        let lerpSpeed = 0.08;
        let audioCtx, bgmInterval;
        let hands, cameraPipe;
        let isExperienceStarted = false;

        const COLORS = [0xFFD700, 0x50C878, 0xFFF8E1, 0xFFD700, 0x00FF7F];

        // --- 1. æ ¸å¿ƒå•Ÿå‹•é‚è¼¯ ---
        
        const startBtn = document.getElementById('start-button');
        
        startBtn.addEventListener('touchstart', handleStart, { passive: false });
        startBtn.addEventListener('click', handleStart);

        function handleStart(e) {
            if (isExperienceStarted) return;
            if (e.type === 'touchstart') e.preventDefault();
            
            isExperienceStarted = true;
            startBtn.innerText = "å•Ÿå‹•ä¸­...";
            
            // A. éŸ³è¨Š
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                audioCtx.resume();
                playBGM();
            } catch (err) {
                console.log("Audio Error:", err);
            }

            // B. ä»‹é¢
            const ls = document.getElementById('loading');
            ls.style.display = 'none';

            // C. 3D
            if (!renderer) initThree();
            
            // D. ç›¸æ©Ÿ
            setTimeout(initCameraSystem, 100);
            
            updateLog("é•·æŒ‰è¢å¹•ä¾†äº’å‹•ï¼");
        }

        function updateLog(msg) {
            const log = document.getElementById('status-log');
            if(log) log.innerText = msg;
        }

        // --- 2. æ”åƒé ­ç³»çµ± ---
        async function initCameraSystem() {
            const video = document.getElementById('input-video');
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error("No camera API");
                }

                // ä½¿ç”¨ç‰¹å®šç‰ˆæœ¬è·¯å¾‘ï¼Œé¿å… Failed to fetch
                const HANDS_VERSION = '0.4.1646424915';
                hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@${HANDS_VERSION}/${f}` });
                
                hands.setOptions({ 
                    maxNumHands: 1, 
                    modelComplexity: 0, 
                    minDetectionConfidence: 0.5, 
                    minTrackingConfidence: 0.5 
                });
                
                hands.onResults(onHandsResults);

                cameraPipe = new Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 480, height: 360
                });

                await cameraPipe.start();
                
                document.getElementById('video-container').style.display = 'block';
                document.getElementById('cam-hint').style.display = 'block';
                updateLog("AI å·²å°±ç·’ï¼šæ¡æ‹³å‡èš");

            } catch (err) {
                console.warn("Camera/AI init failed (Touch Only mode):", err);
                updateLog("ç›¸æ©Ÿé€£æ¥å¤±æ•—ï¼Œè«‹ä½¿ç”¨è§¸æ§æ¨¡å¼");
            }
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                let closed = 0;
                if (lm[8].y > lm[6].y) closed++;  
                if (lm[12].y > lm[10].y) closed++; 
                if (lm[16].y > lm[14].y) closed++; 
                if (lm[20].y > lm[18].y) closed++; 
                toggleState(closed >= 3);
            }
        }

        // --- 3. éŸ³æ•ˆç³»çµ± ---
        function playBGM() {
            if (bgmInterval) return;
            const sequence = () => {
                const notes = [64, 67, 71, 74, 76, 71]; 
                notes.forEach((n, i) => {
                    if (!audioCtx) return;
                    const t = audioCtx.currentTime + i * 0.6;
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440 * Math.pow(2, (n - 69) / 12), t);
                    
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.05, t + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
                    
                    osc.connect(gain); gain.connect(audioCtx.destination);
                    osc.start(t); osc.stop(t + 2);
                });
            };
            sequence();
            bgmInterval = setInterval(sequence, 4000);
        }

        function playSound(type) {
            if(!audioCtx || audioCtx.state !== 'running') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const t = audioCtx.currentTime;

            if(type === 'ting') {
                osc.frequency.setValueAtTime(1200, t);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
            } else { 
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.4);
                gain.gain.setValueAtTime(0.05, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.4);
            }
            
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(t); osc.stop(t + 0.5);
        }

        // --- 4. 3D è¦–è¦ºç³»çµ± ---
        function initThree() {
            const container = document.body;
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 18);

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(particleCount * 3);
            const cols = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                pos[i*3]=(Math.random()-0.5)*40; 
                pos[i*3+1]=(Math.random()-0.5)*40; 
                pos[i*3+2]=(Math.random()-0.5)*40;
                const c = new THREE.Color(COLORS[i % COLORS.length]);
                cols[i*3]=c.r; cols[i*3+1]=c.g; cols[i*3+2]=c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));

            const mat = new THREE.PointsMaterial({
                size: 0.18, 
                vertexColors: true, 
                transparent: true, 
                opacity: 0.9, 
                blending: THREE.AdditiveBlending, 
                depthWrite: false
            });

            particles = new THREE.Points(geo, mat);
            scene.add(particles);

            particles.userData.treeTargets = generateTreeTargets();
            particles.userData.scatterTargets = generateScatterTargets();

            animate();
            
            // äº’å‹•äº‹ä»¶ç¶å®š
            const handleInteract = (e) => { 
                if(e.cancelable) e.preventDefault(); 
                toggleState(true); 
            };
            const handleRelease = (e) => { 
                if(e.cancelable) e.preventDefault();
                toggleState(false); 
            };

            window.addEventListener('touchstart', handleInteract, { passive: false });
            window.addEventListener('touchend', handleRelease, { passive: false });
            window.addEventListener('mousedown', handleInteract);
            window.addEventListener('mouseup', handleRelease);
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function generateTreeTargets() {
            const t = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const h = 12, py = Math.random()*h-4;
                const r = ((h-(py+4))/h)*5.5; 
                const a = Math.random()*Math.PI*2;
                t[i*3] = Math.cos(a)*r*(0.8+Math.random()*0.2); 
                t[i*3+1] = py; 
                t[i*3+2] = Math.sin(a)*r*(0.8+Math.random()*0.2);
            }
            return t;
        }

        function generateScatterTargets() {
            const t = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const r = 15+Math.random()*15, th = Math.random()*Math.PI*2, ph = Math.acos(2*Math.random()-1);
                t[i*3]=r*Math.sin(ph)*Math.cos(th); 
                t[i*3+1]=r*Math.sin(ph)*Math.sin(th); 
                t[i*3+2]=r*Math.cos(ph);
            }
            return t;
        }

        function toggleState(fist) {
            if (isFist !== fist) {
                isFist = fist;
                const title = document.getElementById('title');
                if (isFist) { 
                    playSound('ting'); 
                    title.classList.add('visible'); 
                } else { 
                    playSound('whoosh'); 
                    title.classList.remove('visible'); 
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!particles) return;

            const pos = particles.geometry.attributes.position.array;
            const targets = isFist ? particles.userData.treeTargets : particles.userData.scatterTargets;
            
            for (let i = 0; i < particleCount; i++) {
                const ix=i*3, iy=i*3+1, iz=i*3+2;
                pos[ix] += (targets[ix]-pos[ix])*lerpSpeed;
                pos[iy] += (targets[iy]-pos[iy])*lerpSpeed;
                pos[iz] += (targets[iz]-pos[iz])*lerpSpeed;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y += isFist ? 0.008 : 0.002;
            
            renderer.render(scene, camera);
        }
        
        window.onload = () => { initThree(); };

    </script>
</body>
</html>